{"ast":null,"code":"/**\r\n * 图片处理工具函数\r\n */\n\n/**\r\n * 将图片转换为JPEG格式并压缩\r\n * @param {File} file - 原始图片文件\r\n * @param {number} quality - 压缩质量，范围0-1，默认0.8\r\n * @param {Function} onProgress - 进度回调函数\r\n * @returns {Promise<File>} - 处理后的图片文件\r\n */\nexport const convertAndCompressImage = (file, quality = 0.8, onProgress) => {\n  return new Promise((resolve, reject) => {\n    // 报告进度：开始\n    if (onProgress) onProgress(0);\n\n    // 检查文件类型\n    if (!file || !file.type.startsWith('image/')) {\n      reject(new Error('无效的图片文件'));\n      return;\n    }\n\n    // 如果已经是JPEG格式且小于2MB，可以直接返回\n    if (file.type === 'image/jpeg' && file.size < 2 * 1024 * 1024) {\n      console.log('文件已经是JPEG格式且小于2MB，跳过处理');\n      if (onProgress) onProgress(100);\n      resolve(file);\n      return;\n    }\n    const reader = new FileReader();\n    reader.onload = e => {\n      // 报告进度：25%\n      if (onProgress) onProgress(25);\n      const img = new Image();\n      img.onload = () => {\n        try {\n          // 报告进度：50%\n          if (onProgress) onProgress(50);\n\n          // 计算合适的尺寸，避免Canvas尺寸过大\n          let width = img.width;\n          let height = img.height;\n\n          // 如果图片尺寸过大，按比例缩小\n          const MAX_WIDTH = 2048;\n          const MAX_HEIGHT = 2048;\n          if (width > MAX_WIDTH || height > MAX_HEIGHT) {\n            if (width > height) {\n              height = Math.round(height * (MAX_WIDTH / width));\n              width = MAX_WIDTH;\n            } else {\n              width = Math.round(width * (MAX_HEIGHT / height));\n              height = MAX_HEIGHT;\n            }\n            console.log(`图片尺寸过大，已调整为 ${width}x${height}`);\n          }\n\n          // 创建canvas\n          const canvas = document.createElement('canvas');\n          canvas.width = width;\n          canvas.height = height;\n\n          // 在canvas上绘制图片\n          const ctx = canvas.getContext('2d');\n          ctx.fillStyle = '#FFFFFF'; // 设置白色背景\n          ctx.fillRect(0, 0, width, height);\n          ctx.drawImage(img, 0, 0, width, height);\n\n          // 报告进度：75%\n          if (onProgress) onProgress(75);\n\n          // 将canvas转换为blob，使用JPEG格式\n          canvas.toBlob(blob => {\n            if (!blob) {\n              reject(new Error('图片转换失败'));\n              return;\n            }\n            try {\n              // 创建新的File对象，使用.jpg扩展名和JPEG MIME类型\n              const newFileName = file.name.replace(/\\.[^/.]+$/, '') + '.jpg';\n              const processedFile = new File([blob], newFileName, {\n                type: 'image/jpeg',\n                lastModified: Date.now()\n              });\n\n              // 报告进度：100%\n              if (onProgress) onProgress(100);\n\n              // 输出压缩信息\n              console.log('原始文件大小:', (file.size / 1024).toFixed(2) + 'KB');\n              console.log('压缩后文件大小:', (processedFile.size / 1024).toFixed(2) + 'KB');\n              console.log('压缩率:', ((1 - processedFile.size / file.size) * 100).toFixed(2) + '%');\n              console.log('处理后的文件名:', processedFile.name);\n              console.log('处理后的文件类型:', processedFile.type);\n              resolve(processedFile);\n            } catch (error) {\n              console.error('创建File对象失败:', error);\n              reject(new Error('创建File对象失败: ' + error.message));\n            }\n          }, 'image/jpeg',\n          // 使用JPEG格式\n          quality // 使用传入的质量参数\n          );\n        } catch (error) {\n          console.error('Canvas处理图片失败:', error);\n          reject(new Error('Canvas处理图片失败: ' + error.message));\n        }\n      };\n      img.onerror = error => {\n        console.error('图片加载失败:', error);\n        reject(new Error('图片加载失败'));\n      };\n\n      // 设置图片源\n      img.src = e.target.result;\n    };\n    reader.onerror = error => {\n      console.error('文件读取失败:', error);\n      reject(new Error('文件读取失败'));\n    };\n\n    // 读取文件为DataURL\n    reader.readAsDataURL(file);\n  });\n};\n\n/**\r\n * 批量处理图片文件\r\n * @param {File[]} files - 图片文件数组\r\n * @param {number} quality - 压缩质量，范围0-1，默认0.8\r\n * @param {Function} onProgress - 进度回调函数\r\n * @returns {Promise<File[]>} - 处理后的图片文件数组\r\n */\nexport const batchProcessImages = async (files, quality = 0.8, onProgress) => {\n  if (!files || files.length === 0) {\n    return [];\n  }\n  const totalFiles = files.length;\n  const processedFiles = [];\n  for (let i = 0; i < totalFiles; i++) {\n    const file = files[i];\n    try {\n      // 计算当前文件的进度范围\n      const startProgress = i / totalFiles * 100;\n      const endProgress = (i + 1) / totalFiles * 100;\n      const processedFile = await convertAndCompressImage(file, quality, progress => {\n        // 将单个文件的进度映射到总体进度范围\n        const mappedProgress = startProgress + progress / 100 * (endProgress - startProgress);\n        if (onProgress) onProgress(Math.round(mappedProgress));\n      });\n      processedFiles.push(processedFile);\n    } catch (error) {\n      console.error(`处理文件 ${file.name} 失败:`, error);\n      // 继续处理其他文件，而不是中断整个过程\n      // 添加原始文件，以便用户仍然可以上传\n      processedFiles.push(file);\n    }\n  }\n  return processedFiles;\n};","map":{"version":3,"names":["convertAndCompressImage","file","quality","onProgress","Promise","resolve","reject","type","startsWith","Error","size","console","log","reader","FileReader","onload","e","img","Image","width","height","MAX_WIDTH","MAX_HEIGHT","Math","round","canvas","document","createElement","ctx","getContext","fillStyle","fillRect","drawImage","toBlob","blob","newFileName","name","replace","processedFile","File","lastModified","Date","now","toFixed","error","message","onerror","src","target","result","readAsDataURL","batchProcessImages","files","length","totalFiles","processedFiles","i","startProgress","endProgress","progress","mappedProgress","push"],"sources":["C:/Users/10150/Desktop/Hazardous-waste-management-system/frontend/src/utils/imageUtils.js"],"sourcesContent":["/**\r\n * 图片处理工具函数\r\n */\r\n\r\n/**\r\n * 将图片转换为JPEG格式并压缩\r\n * @param {File} file - 原始图片文件\r\n * @param {number} quality - 压缩质量，范围0-1，默认0.8\r\n * @param {Function} onProgress - 进度回调函数\r\n * @returns {Promise<File>} - 处理后的图片文件\r\n */\r\nexport const convertAndCompressImage = (file, quality = 0.8, onProgress) => {\r\n  return new Promise((resolve, reject) => {\r\n    // 报告进度：开始\r\n    if (onProgress) onProgress(0);\r\n    \r\n    // 检查文件类型\r\n    if (!file || !file.type.startsWith('image/')) {\r\n      reject(new Error('无效的图片文件'));\r\n      return;\r\n    }\r\n    \r\n    // 如果已经是JPEG格式且小于2MB，可以直接返回\r\n    if (file.type === 'image/jpeg' && file.size < 2 * 1024 * 1024) {\r\n      console.log('文件已经是JPEG格式且小于2MB，跳过处理');\r\n      if (onProgress) onProgress(100);\r\n      resolve(file);\r\n      return;\r\n    }\r\n    \r\n    const reader = new FileReader();\r\n    \r\n    reader.onload = (e) => {\r\n      // 报告进度：25%\r\n      if (onProgress) onProgress(25);\r\n      \r\n      const img = new Image();\r\n      \r\n      img.onload = () => {\r\n        try {\r\n          // 报告进度：50%\r\n          if (onProgress) onProgress(50);\r\n          \r\n          // 计算合适的尺寸，避免Canvas尺寸过大\r\n          let width = img.width;\r\n          let height = img.height;\r\n          \r\n          // 如果图片尺寸过大，按比例缩小\r\n          const MAX_WIDTH = 2048;\r\n          const MAX_HEIGHT = 2048;\r\n          \r\n          if (width > MAX_WIDTH || height > MAX_HEIGHT) {\r\n            if (width > height) {\r\n              height = Math.round(height * (MAX_WIDTH / width));\r\n              width = MAX_WIDTH;\r\n            } else {\r\n              width = Math.round(width * (MAX_HEIGHT / height));\r\n              height = MAX_HEIGHT;\r\n            }\r\n            console.log(`图片尺寸过大，已调整为 ${width}x${height}`);\r\n          }\r\n          \r\n          // 创建canvas\r\n          const canvas = document.createElement('canvas');\r\n          canvas.width = width;\r\n          canvas.height = height;\r\n          \r\n          // 在canvas上绘制图片\r\n          const ctx = canvas.getContext('2d');\r\n          ctx.fillStyle = '#FFFFFF'; // 设置白色背景\r\n          ctx.fillRect(0, 0, width, height);\r\n          ctx.drawImage(img, 0, 0, width, height);\r\n          \r\n          // 报告进度：75%\r\n          if (onProgress) onProgress(75);\r\n          \r\n          // 将canvas转换为blob，使用JPEG格式\r\n          canvas.toBlob(\r\n            (blob) => {\r\n              if (!blob) {\r\n                reject(new Error('图片转换失败'));\r\n                return;\r\n              }\r\n              \r\n              try {\r\n                // 创建新的File对象，使用.jpg扩展名和JPEG MIME类型\r\n                const newFileName = file.name.replace(/\\.[^/.]+$/, '') + '.jpg';\r\n                const processedFile = new File([blob], newFileName, {\r\n                  type: 'image/jpeg',\r\n                  lastModified: Date.now()\r\n                });\r\n                \r\n                // 报告进度：100%\r\n                if (onProgress) onProgress(100);\r\n                \r\n                // 输出压缩信息\r\n                console.log('原始文件大小:', (file.size / 1024).toFixed(2) + 'KB');\r\n                console.log('压缩后文件大小:', (processedFile.size / 1024).toFixed(2) + 'KB');\r\n                console.log('压缩率:', ((1 - processedFile.size / file.size) * 100).toFixed(2) + '%');\r\n                console.log('处理后的文件名:', processedFile.name);\r\n                console.log('处理后的文件类型:', processedFile.type);\r\n                \r\n                resolve(processedFile);\r\n              } catch (error) {\r\n                console.error('创建File对象失败:', error);\r\n                reject(new Error('创建File对象失败: ' + error.message));\r\n              }\r\n            },\r\n            'image/jpeg', // 使用JPEG格式\r\n            quality // 使用传入的质量参数\r\n          );\r\n        } catch (error) {\r\n          console.error('Canvas处理图片失败:', error);\r\n          reject(new Error('Canvas处理图片失败: ' + error.message));\r\n        }\r\n      };\r\n      \r\n      img.onerror = (error) => {\r\n        console.error('图片加载失败:', error);\r\n        reject(new Error('图片加载失败'));\r\n      };\r\n      \r\n      // 设置图片源\r\n      img.src = e.target.result;\r\n    };\r\n    \r\n    reader.onerror = (error) => {\r\n      console.error('文件读取失败:', error);\r\n      reject(new Error('文件读取失败'));\r\n    };\r\n    \r\n    // 读取文件为DataURL\r\n    reader.readAsDataURL(file);\r\n  });\r\n};\r\n\r\n/**\r\n * 批量处理图片文件\r\n * @param {File[]} files - 图片文件数组\r\n * @param {number} quality - 压缩质量，范围0-1，默认0.8\r\n * @param {Function} onProgress - 进度回调函数\r\n * @returns {Promise<File[]>} - 处理后的图片文件数组\r\n */\r\nexport const batchProcessImages = async (files, quality = 0.8, onProgress) => {\r\n  if (!files || files.length === 0) {\r\n    return [];\r\n  }\r\n  \r\n  const totalFiles = files.length;\r\n  const processedFiles = [];\r\n  \r\n  for (let i = 0; i < totalFiles; i++) {\r\n    const file = files[i];\r\n    try {\r\n      // 计算当前文件的进度范围\r\n      const startProgress = (i / totalFiles) * 100;\r\n      const endProgress = ((i + 1) / totalFiles) * 100;\r\n      \r\n      const processedFile = await convertAndCompressImage(\r\n        file,\r\n        quality,\r\n        (progress) => {\r\n          // 将单个文件的进度映射到总体进度范围\r\n          const mappedProgress = startProgress + (progress / 100) * (endProgress - startProgress);\r\n          if (onProgress) onProgress(Math.round(mappedProgress));\r\n        }\r\n      );\r\n      \r\n      processedFiles.push(processedFile);\r\n    } catch (error) {\r\n      console.error(`处理文件 ${file.name} 失败:`, error);\r\n      // 继续处理其他文件，而不是中断整个过程\r\n      // 添加原始文件，以便用户仍然可以上传\r\n      processedFiles.push(file);\r\n    }\r\n  }\r\n  \r\n  return processedFiles;\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}